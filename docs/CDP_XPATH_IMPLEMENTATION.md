# CDP and XPath Implementation Documentation

## Overview

This document explains how AI Browser Automation uses Chrome DevTools Protocol (CDP) and XPath to identify and interact with web elements. This implementation provides reliable element identification across different websites.

## Architecture Overview

```
┌─────────────────┐
│ AIBrowserAutomationPage │
├─────────────────┤
│ Frame Tracking  │
│ CDP Session     │
└────────┬────────┘
         │
         ▼
┌─────────────────────┐     ┌──────────────────┐
│ AccessibilityTree   │────▶│  CDP Session     │
│      Builder        │     │  - DOM.enable    │
└─────────┬───────────┘     │  - A11y.enable   │
          │                 └──────────────────┘
          ▼
┌─────────────────────┐
│  Observe Handler    │
├─────────────────────┤
│ 1. Get A11y Tree    │
│ 2. Build XPath Map  │
│ 3. Send to LLM      │
│ 4. Return Selectors │
└─────────────────────┘
```

## Key Components

### 1. Frame Ordinal System

Each frame (including iframes) gets a unique ordinal number:

```python
# In AIBrowserAutomationPage
self._frame_ordinals: Dict[Optional[str], int] = {None: 0}  # Main frame = 0
self._next_frame_ordinal = 1

def encode_with_frame_id(self, frame_id: Optional[str], backend_id: int) -> str:
    """Creates encoded ID format: {frameOrdinal}-{backendNodeId}"""
    # Example: "0-123" for main frame, "1-456" for first iframe
    ordinal = self.ordinal_for_frame_id(frame_id)
    return f"{ordinal}-{backend_id}"
```

### 2. CDP Session Management

CDP (Chrome DevTools Protocol) provides low-level access to browser internals:

```python
# Create CDP session
cdp_session = await page.context.new_cdp_session(page)

# Enable required domains
await cdp_session.send("DOM.enable")         # Access to DOM tree
await cdp_session.send("Accessibility.enable") # Access to accessibility tree
```

### 3. Accessibility Tree Building

The accessibility tree provides semantic information about page elements:

```python
# Get accessibility tree
ax_tree_response = await cdp_session.send("Accessibility.getFullAXTree")
nodes = ax_tree_response.get("nodes", [])

# Each node contains:
{
    "nodeId": "abc123",
    "backendDOMNodeId": 456,  # Maps to DOM node
    "role": {"value": "button"},
    "name": {"value": "Submit"},
    "ignored": false
}
```

### 4. XPath Generation

XPaths are generated by traversing the DOM tree:

```python
# Get full DOM tree
dom_response = await cdp_session.send("DOM.getDocument", {"depth": -1})

# Traverse and build XPaths
def traverse_node(node, parent_xpath="", position_map=None):
    node_type = node.get("nodeType")
    
    if node_type == 1:  # ELEMENT_NODE
        # Calculate position among siblings
        position = position_map.get(parent_key, 0) + 1
        xpath = f"{parent_xpath}/{node_name}[{position}]"
        
        # Map backend ID to XPath
        xpath_map[backend_id] = xpath
```

## Complete Workflow

### Phase 1: Page Analysis

1. **User calls `page.observe()` or `page.act()`**
   ```python
   results = await page.observe("Find the submit button")
   ```

2. **Gather page information**
   ```python
   # In ObserveHandler._gather_page_info()
   simplified_tree, xpath_map, url_map = await get_accessibility_tree(page)
   ```

3. **Build accessibility tree with CDP**
   ```python
   async with AccessibilityTreeBuilder(page) as builder:
       # This creates CDP session and enables domains
       return await builder.get_accessibility_tree_with_frames()
   ```

### Phase 2: Element Mapping

1. **Get DOM tree with backend IDs**
   ```python
   # CDP returns full DOM tree
   dom = await cdp_session.send("DOM.getDocument", {"depth": -1})
   # Result includes backendNodeId for each element
   ```

2. **Build XPath mappings**
   ```python
   # For each DOM node:
   # - Calculate its position among siblings
   # - Build XPath: /html[1]/body[1]/div[2]/button[1]
   # - Map: backendNodeId → XPath
   xpath_map = {
       123: "/html[1]/body[1]/div[1]",
       456: "/html[1]/body[1]/div[1]/button[1]",
       # ...
   }
   ```

3. **Match accessibility nodes to DOM nodes**
   ```python
   # Each accessibility node has backendDOMNodeId
   # Use this to look up the XPath
   for node in accessibility_nodes:
       backend_id = node.get("backendDOMNodeId")
       if backend_id in xpath_map:
           node["xpath"] = xpath_map[backend_id]
   ```

### Phase 3: LLM Processing

1. **Build prompt with encoded IDs**
   ```python
   # Prompt includes elements like:
   # - [0-456] BUTTON: "Submit Form"
   # - [0-789] INPUT: "Email address"
   ```

2. **LLM returns element IDs**
   ```json
   {
     "elementId": "0-456",
     "description": "Submit button",
     "method": "click",
     "arguments": []
   }
   ```

3. **Convert to XPath selectors**
   ```python
   # Look up XPath for encoded ID
   encoded_id = "0-456"
   xpath = xpath_map[encoded_id]  # "/html[1]/body[1]/div[1]/button[1]"
   selector = f"xpath={xpath}"     # "xpath=/html[1]/body[1]/div[1]/button[1]"
   ```

### Phase 4: Action Execution

1. **Clean selector for Playwright**
   ```python
   # Remove "xpath=" prefix if needed
   cleaned = selector.replace("xpath=", "").strip()
   ```

2. **Execute action**
   ```python
   locator = page.locator(f"xpath={cleaned}")
   await locator.click()  # or fill, type, etc.
   ```

## Key Differences from Simple DOM Scraping

### Traditional Approach:
- Scrapes visible DOM elements
- Uses CSS selectors or simple XPath
- May miss dynamically loaded content
- Can't access accessibility information

### CDP Approach:
- Gets complete DOM tree including hidden elements
- Accesses accessibility tree for semantic information
- Generates precise XPaths for every element
- Handles iframes with frame ordinals
- More reliable for complex web apps

## Error Handling

### CDP Connection Errors
```python
try:
    cdp_session = await context.new_cdp_session(page)
except Exception as e:
    # Fall back to DOM scraping
    return await self._fallback_dom_scraping(page)
```

### Missing Backend IDs
```python
if not backend_id:
    # Some nodes (like text nodes) might not have backend IDs
    # Skip or use alternative identification
    continue
```

### XPath Generation Failures
```python
if encoded_id not in xpath_map:
    # Log warning and use basic selector
    self._log_warning(f"No XPath found for {encoded_id}")
    selector = f"xpath=//{tag_name}"  # Fallback
```

## Benefits of This Approach

1. **Accuracy**: XPaths are generated from the actual DOM structure
2. **Reliability**: Not affected by CSS changes or dynamic classes
3. **Completeness**: Accesses all elements, even hidden ones
4. **Semantic Understanding**: Uses accessibility roles and names
5. **Frame Support**: Handles iframes with unique identifiers

## Debugging Tips

### 1. Check CDP Connection
```python
# In test script
cdp_session = await context.new_cdp_session(page)
print("CDP session created:", cdp_session)
```

### 2. Verify Accessibility Tree
```python
# Get raw accessibility tree
tree = await cdp_session.send("Accessibility.getFullAXTree")
print(f"Got {len(tree['nodes'])} accessibility nodes")
```

### 3. Debug XPath Mapping
```python
# In AccessibilityTreeBuilder
print(f"Mapped {len(xpath_map)} backend IDs to XPaths")
for backend_id, xpath in list(xpath_map.items())[:5]:
    print(f"  {backend_id}: {xpath}")
```

### 4. Trace Element Selection
```python
# In ObserveHandler
print(f"LLM returned elementId: {elem_data.get('elementId')}")
print(f"Found XPath: {xpath_map.get(encoded_id)}")
print(f"Final selector: {selector}")
```

## Common Issues and Solutions

### Issue: "No XPath found for element"
**Cause**: Element might be dynamically added after DOM snapshot
**Solution**: Retry with fresh DOM tree or use fallback selectors

### Issue: "Invalid XPath expression"
**Cause**: Special characters in XPath not properly escaped
**Solution**: Ensure XPath building handles special cases

### Issue: "Element not found with XPath"
**Cause**: Page changed between analysis and action
**Solution**: Add retry logic or re-observe before action

## Example: Complete Flow

```python
# 1. User request
await page.act("Click the login button")

# 2. Behind the scenes:
# - CDP gets accessibility tree with 50 nodes
# - CDP gets DOM tree with 200 nodes
# - Builds XPath map: {123: "/html/body/header/button[1]", ...}
# - Sends to LLM: "Find element to click for: login button"
# - LLM returns: {"elementId": "0-123", "method": "click"}
# - Looks up XPath: "/html/body/header/button[1]"
# - Executes: await page.locator("xpath=/html/body/header/button[1]").click()

# 3. Result
ActResult(success=True, action="click", selector="xpath=/html/body/header/button[1]")
```

## Performance Considerations

1. **CDP Overhead**: ~100-200ms to get accessibility tree
2. **XPath Building**: ~50ms for typical page
3. **Caching**: XPath mappings can be cached per URL
4. **Fallback**: DOM scraping available if CDP fails

## Future Enhancements

1. **Iframe Support**: Full multi-frame XPath generation
2. **Shadow DOM**: Handle web components
3. **Performance**: Cache XPath mappings
4. **Reliability**: Retry logic for dynamic pages